import streamlit as st
import pandas as pd
from datetime import date, timedelta
import json
import plotly.express as px

# ============================
# CONFIG / MODE D'EMPLOI
# ============================
# 1) Installer les d√©pendances :
#    pip install -r requirements.txt
# 2) Lancer l'app :
#    streamlit run apiplan_pro_v2.py
#
# Astuce : change YEAR si tu veux pr√©parer une autre saison.
YEAR = date.today().year

st.set_page_config(page_title="APIPlan PRO v2 ‚Äì Multiplication, √âlevage, Miel", layout="wide")
st.title("APIPlan PRO v2 ‚Äì Multiplication ‚Ä¢ √âlevage ‚Ä¢ Miel (estimation)")
st.caption("Tu saisis tes actions + √©levage, l‚Äôoutil calcule objectifs, calendrier, besoins en cellules, et miel estim√© (impact divisions).")

# ----------------------------
# Param√®tres g√©n√©raux
# ----------------------------
with st.sidebar:
    st.header("Pertes & Objectif")
    loss_created = st.slider("Pertes sur essaims cr√©√©s (%)", 0, 80, 30, 1) / 100
    loss_winter = st.slider("Pertes hivernales (%)", 0, 80, 20, 1) / 100
    target_end = st.number_input("Objectif apr√®s hiver (colonies)", min_value=1, value=50, step=1)

    st.divider()
    st.header("√âlevage (r√©glages)")
    st.caption("Par d√©faut : cellules opercul√©es introduites le jour J.")
    graft_to_capped = st.number_input("Greffage ‚Üí Cellule opercul√©e (jours)", 6, 14, 10, 1)
    graft_to_emerge = st.number_input("Greffage ‚Üí Naissance reine (jours)", 12, 20, 16, 1)
    emerge_to_mating = st.number_input("Naissance ‚Üí F√©condation (jours)", 5, 20, 10, 1)
    mating_to_laying = st.number_input("F√©condation ‚Üí Ponte stable (jours)", 3, 20, 7, 1)

    st.divider()
    st.header("Miel (param√®tres)")
    st.caption("Tu r√®gles selon ton secteur/miell√©es/ann√©e.")
    base_yield = st.number_input("Rendement moyen par ruche productive (kg)", 0.0, 80.0, 18.0, 0.5)
    # P√©nalit√© miel par division selon le mois (plus t√¥t = impact + fort)
    pen_apr = st.number_input("Perte miel par division en AVRIL (kg)", 0.0, 50.0, 6.0, 0.5)
    pen_may = st.number_input("Perte miel par division en MAI (kg)", 0.0, 50.0, 4.0, 0.5)
    pen_jun = st.number_input("Perte miel par division en JUIN+ (kg)", 0.0, 50.0, 2.0, 0.5)
    nuc_yield = st.number_input("Rendement moyen d‚Äôune ruchette (kg)", 0.0, 30.0, 0.0, 0.5)
    st.caption("Astuce pro : mets 0 kg sur ruchette si tu ne veux pas compter de miel dessus.")

# ----------------------------
# D√©part
# ----------------------------
st.subheader("1) Cheptel de d√©part")
c1, c2, c3 = st.columns(3)
with c1:
    start_hives = st.number_input("Ruches au d√©part", 0, 999, 9, 1)
with c2:
    start_nucs = st.number_input("Ruchettes au d√©part", 0, 999, 7, 1)
with c3:
    start_total = start_hives + start_nucs
    st.metric("Total d√©part", start_total)

# ----------------------------
# Sauvegarde/chargement JSON
# ----------------------------
def df_to_json(df: pd.DataFrame) -> str:
    d = df.copy()
    d["Date"] = pd.to_datetime(d["Date"]).dt.strftime("%Y-%m-%d")
    return json.dumps(d.to_dict(orient="records"), ensure_ascii=False, indent=2)

def df_from_json(s: str) -> pd.DataFrame:
    records = json.loads(s)
    df = pd.DataFrame(records)
    df["Date"] = pd.to_datetime(df["Date"]).dt.date
    return df

# ----------------------------
# ACTIONS (colonies)
# ----------------------------
st.subheader("2) Actions colonies (tu remplis)")
st.caption("‚ö†Ô∏è Important pour le miel : utilise 'Division' / 'Redivision' pour les essaims cr√©√©s. 'Perte' = pertes constat√©es (hors %).")

if "actions" not in st.session_state:
    st.session_state.actions = pd.DataFrame(
        [
            {"Date": date(YEAR, 4, 10), "Action": "Division", "Quantit√©": 10, "Besoin_cellule": True, "Notes": ""},
            {"Date": date(YEAR, 5, 10), "Action": "Redivision", "Quantit√©": 10, "Besoin_cellule": True, "Notes": ""},
        ]
    )

a1, a2, a3 = st.columns([1, 1, 2])
with a1:
    if st.button("‚ûï Ajouter action"):
        st.session_state.actions = pd.concat(
            [st.session_state.actions, pd.DataFrame([{"Date": date.today(), "Action": "Division", "Quantit√©": 0, "Besoin_cellule": False, "Notes": ""}])],
            ignore_index=True
        )
with a2:
    if st.button("üßπ Reset exemple (actions)"):
        st.session_state.actions = pd.DataFrame(
            [
                {"Date": date(YEAR, 4, 10), "Action": "Division", "Quantit√©": 10, "Besoin_cellule": True, "Notes": ""},
                {"Date": date(YEAR, 5, 10), "Action": "Redivision", "Quantit√©": 10, "Besoin_cellule": True, "Notes": ""},
            ]
        )
with a3:
    up = st.file_uploader("Charger plan Actions (JSON)", type=["json"], key="up_actions")
    if up is not None:
        st.session_state.actions = df_from_json(up.read().decode("utf-8"))

actions = st.data_editor(
    st.session_state.actions,
    use_container_width=True,
    num_rows="dynamic",
    column_config={
        "Date": st.column_config.DateColumn(format="DD/MM/YYYY"),
        "Action": st.column_config.SelectboxColumn(options=["Division", "Redivision", "Achat", "Perte"]),
        "Quantit√©": st.column_config.NumberColumn(min_value=0, step=1),
        "Besoin_cellule": st.column_config.CheckboxColumn(help="Coche si tu introduis une cellule ce jour-l√†"),
        "Notes": st.column_config.TextColumn(),
    },
)
st.session_state.actions = actions.copy()

# ----------------------------
# DONNEUSES (pour le miel)
# ----------------------------
st.subheader("3) Donneuses (pour estimer le miel)")
st.caption("Ici tu indiques combien de RUCHES tu divises, et quand. √áa sert uniquement √† estimer l‚Äôimpact sur la r√©colte.")

if "donors" not in st.session_state:
    st.session_state.donors = pd.DataFrame(
        [
            {"Date": date(YEAR, 4, 10), "Ruches_divis√©es": 6, "Divisions_par_ruche": 1, "Notes": "S√©rie 1"},
            {"Date": date(YEAR, 5, 10), "Ruches_divis√©es": 5, "Divisions_par_ruche": 1, "Notes": "S√©rie 2"},
        ]
    )

d1, d2, d3 = st.columns([1, 1, 2])
with d1:
    if st.button("‚ûï Ajouter donneuses"):
        st.session_state.donors = pd.concat(
            [st.session_state.donors, pd.DataFrame([{"Date": date.today(), "Ruches_divis√©es": 0, "Divisions_par_ruche": 1, "Notes": ""}])],
            ignore_index=True
        )
with d2:
    if st.button("üßπ Reset exemple (donneuses)"):
        st.session_state.donors = pd.DataFrame(
            [
                {"Date": date(YEAR, 4, 10), "Ruches_divis√©es": 6, "Divisions_par_ruche": 1, "Notes": "S√©rie 1"},
                {"Date": date(YEAR, 5, 10), "Ruches_divis√©es": 5, "Divisions_par_ruche": 1, "Notes": "S√©rie 2"},
            ]
        )
with d3:
    up2 = st.file_uploader("Charger plan Donneuses (JSON)", type=["json"], key="up_donors")
    if up2 is not None:
        st.session_state.donors = df_from_json(up2.read().decode("utf-8"))

donors = st.data_editor(
    st.session_state.donors,
    use_container_width=True,
    num_rows="dynamic",
    column_config={
        "Date": st.column_config.DateColumn(format="DD/MM/YYYY"),
        "Ruches_divis√©es": st.column_config.NumberColumn(min_value=0, step=1),
        "Divisions_par_ruche": st.column_config.NumberColumn(min_value=0, step=1),
        "Notes": st.column_config.TextColumn(),
    }
)
st.session_state.donors = donors.copy()

# ----------------------------
# Calculs Colonies
# ----------------------------
def compute_colonies(actions_df: pd.DataFrame):
    d = actions_df.copy()
    d["Date"] = pd.to_datetime(d["Date"]).dt.date
    d["Quantit√©"] = pd.to_numeric(d["Quantit√©"], errors="coerce").fillna(0).astype(int)
    d = d.sort_values("Date")

    created_gross = int(d.loc[d["Action"].isin(["Division", "Redivision"]), "Quantit√©"].sum())
    bought = int(d.loc[d["Action"] == "Achat", "Quantit√©"].sum())
    losses_manual = int(d.loc[d["Action"] == "Perte", "Quantit√©"].sum())

    created_survive = round(created_gross * (1 - loss_created))
    pre_winter = start_total + created_survive + bought - losses_manual
    after_winter = round(pre_winter * (1 - loss_winter))

    needed_pre_winter = int((target_end / (1 - loss_winter)) + 0.9999)  # ceil
    needed_net_add = max(0, needed_pre_winter - start_total)
    needed_gross_created = int((needed_net_add / (1 - loss_created)) + 0.9999)  # ceil

    d["Cellules_requises"] = d.apply(
        lambda r: int(r["Quantit√©"]) if (r.get("Besoin_cellule", False) and r["Action"] in ["Division", "Redivision"]) else 0,
        axis=1
    )

    return d, {
        "created_gross": created_gross,
        "created_survive": created_survive,
        "bought": bought,
        "losses_manual": losses_manual,
        "pre_winter": pre_winter,
        "after_winter": after_winter,
        "needed_pre_winter": needed_pre_winter,
        "needed_gross_created": needed_gross_created
    }

d_actions, k = compute_colonies(actions)

k1, k2, k3, k4, k5 = st.columns(5)
k1.metric("Cr√©√©s (brut)", k["created_gross"])
k2.metric("Cr√©√©s (survivants ~)", k["created_survive"])
k3.metric("Achats", k["bought"])
k4.metric("√Ä hiverner (estim.)", k["pre_winter"])
k5.metric("Apr√®s hiver (estim.)", k["after_winter"])

st.info(
    f"Objectif {target_end} apr√®s hiver ‚Üí viser **{k['needed_pre_winter']} √† hiverner**. "
    f"Avec {start_total} au d√©part + {int(loss_created*100)}% pertes cr√©ation, il faut environ **{k['needed_gross_created']} essaims √† cr√©er**."
)

# ----------------------------
# Timeline (calendrier)
# ----------------------------
st.subheader("4) Calendrier (timeline)")
if not d_actions.empty:
    dt = d_actions.copy()
    dt["Start"] = pd.to_datetime(dt["Date"])
    dt["Finish"] = dt["Start"] + pd.to_timedelta(1, unit="D")
    dt["Label"] = dt["Date"].astype(str) + " ‚Äî " + dt["Action"] + " (" + dt["Quantit√©"].astype(str) + ")"
    fig = px.timeline(dt, x_start="Start", x_end="Finish", y="Label")
    fig.update_yaxes(autorange="reversed")
    st.plotly_chart(fig, use_container_width=True)

# ----------------------------
# √âlevage: planning cellules
# ----------------------------
st.subheader("5) √âlevage ‚Äî besoins en cellules & dates")
need = d_actions[d_actions["Cellules_requises"] > 0][["Date", "Action", "Quantit√©", "Cellules_requises", "Notes"]].copy()
if need.empty:
    st.write("Coche **Besoin_cellule** sur tes divisions/redivisions pour g√©n√©rer le planning √©levage.")
else:
    need["Date_introduction_cellules"] = need["Date"]
    need["Date_greffage"] = need["Date"].apply(lambda x: x - timedelta(days=int(graft_to_capped)))
    need["Naissance_reines_est"] = need["Date_greffage"].apply(lambda x: x + timedelta(days=int(graft_to_emerge)))
    need["F√©condation_est"] = need["Naissance_reines_est"].apply(lambda x: x + timedelta(days=int(emerge_to_mating)))
    need["Ponte_stable_est"] = need["F√©condation_est"].apply(lambda x: x + timedelta(days=int(mating_to_laying)))
    st.dataframe(need, use_container_width=True)

# ----------------------------
# Miel: estimation avec impact divisions
# ----------------------------
st.subheader("6) Miel estim√© (impact divisions)")
st.caption("Mod√®le simple mais pro : base kg/ruche productive - p√©nalit√©s par division (selon p√©riode). Tu peux r√©gler les kg dans la sidebar.")

def penalty_for_month(d: date):
    if d.month <= 4:
        return pen_apr
    elif d.month == 5:
        return pen_may
    else:
        return pen_jun

don = donors.copy()
don["Date"] = pd.to_datetime(don["Date"]).dt.date
don["Ruches_divis√©es"] = pd.to_numeric(don["Ruches_divis√©es"], errors="coerce").fillna(0).astype(int)
don["Divisions_par_ruche"] = pd.to_numeric(don["Divisions_par_ruche"], errors="coerce").fillna(0).astype(int)
don = don.sort_values("Date")

productive_hives = start_hives

don["Divisions_total"] = don["Ruches_divis√©es"] * don["Divisions_par_ruche"]
don["Penalite_par_division"] = don["Date"].apply(penalty_for_month)
don["Penalite_kg"] = don["Divisions_total"] * don["Penalite_par_division"]
total_penalty = float(don["Penalite_kg"].sum())

gross_honey = productive_hives * float(base_yield)
honey_after_penalty = max(0.0, gross_honey - total_penalty)

estimated_nuc_honey = start_nucs * float(nuc_yield)
total_honey = honey_after_penalty + estimated_nuc_honey

cA, cB, cC = st.columns(3)
cA.metric("Base (kg) = ruches productives √ó rendement", f"{gross_honey:.1f}")
cB.metric("P√©nalit√© divisions (kg)", f"-{total_penalty:.1f}")
cC.metric("Miel estim√© total (kg)", f"{total_honey:.1f}")

if not don.empty:
    st.write("D√©tail p√©nalit√©s divisions :")
    st.dataframe(don[["Date","Ruches_divis√©es","Divisions_par_ruche","Divisions_total","Penalite_par_division","Penalite_kg","Notes"]], use_container_width=True)

# ----------------------------
# Sauvegarde / export
# ----------------------------
st.subheader("7) Sauvegarder / Exporter")
colA, colB, colC, colD = st.columns(4)

with colA:
    st.download_button("üíæ Actions (JSON)", df_to_json(d_actions).encode("utf-8"),
                       file_name="apiplan_actions.json", mime="application/json")
with colB:
    st.download_button("üì§ Actions (CSV)", d_actions.to_csv(index=False).encode("utf-8"),
                       file_name="apiplan_actions.csv", mime="text/csv")
with colC:
    st.download_button("üíæ Donneuses (JSON)", df_to_json(don).encode("utf-8"),
                       file_name="apiplan_donneuses.json", mime="application/json")
with colD:
    st.download_button("üì§ Donneuses (CSV)", don.to_csv(index=False).encode("utf-8"),
                       file_name="apiplan_donneuses.csv", mime="text/csv")
